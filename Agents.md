---
title: Codex Agents for the Semantic Network Walker
kind: meta
source: documentation/Agents.md
last_updated: 2025-11-24
---

# Codex Agents Configuration for the Semantic Network Walker

This file defines **how Codex should operate** when handling tasks related to this repository.

It does **not** describe Obsidian “agents” or any runtime plugin objects.  
Instead, it declares **Codex modes** that govern:

- the JavaScript UI for walking semantic networks,
- the file structure for UI modules,
- how network JSON files are read and respected,
- how DataviewJS entrypoints should look,
- how front-end and back-end responsibilities stay cleanly separated.

Whenever working inside this repository, Codex must:

1. Treat the **semantic network JSON** as an external data product (generated by Python or other tools).
2. Focus on **UI, interaction, and reading data**, not on embedding models or similarity computation.
3. Respect the structural and architectural rules in this `Agents.md` for all tasks.

---

## 1. Global Principles (Apply to ALL Modes)

These rules are universal:

1. **Front-End Only, Unless Explicitly Asked Otherwise**  
   - The purpose of this repo is to provide a **semantic network walker UI** for Obsidian:
     - JavaScript modules loaded via DataviewJS or the Obsidian plugin API.
     - Minimal, declarative DataviewJS blocks.
     - Clear separation between front-end (JS) and back-end (Python / embeddings).
   - Codex must **not** implement or modify embedding or similarity computation unless the user explicitly requests it.

2. **Semantic Networks are Read-Only by Default**  
   - Network JSON files are treated as **inputs**, not something the UI silently rewrites.
   - Codex may propose or implement **separate writer scripts** (e.g. `tools/` or `python/`) if the user asks, but the default behavior in UI code is:
     - read network → display nodes and neighbors → track navigation in memory only.

3. **Always Externalize Paths & Parameters**  
   - Paths MUST NOT be hard-coded inside reusable functions.
   - Any UI entrypoint must accept explicit parameters, such as:
     - `networkPath` (path to JSON file inside the vault),
     - `container` (DOM element from DataviewJS),
     - optional: `startNode`, `randomStart`, `maxNeighbors`.
   - Default values may exist, but API signatures must remain explicit.

4. **Simple, Inspectable Data Structures**  
   - The UI must assume a **JSON adjacency list** of the form:
     ```json
     {
       "id": "example-network",
       "description": "Short human-readable description.",
       "nodes": [
         {
           "id": 0,
           "text": "Sentence text…",
           "neighbors": [
             { "id": 12, "sim": 0.89 },
             { "id": 7,  "sim": 0.84 }
           ]
         }
       ]
     }
     ```
   - Codex must not introduce alternative, incompatible formats without clearly documenting the change.

5. **Documentation Means Usage Clarity**  
   - When asked to update docs:
     - Explain how to call the main entrypoint from DataviewJS.
     - Explain the expected JSON format.
     - Explain the module responsibilities (UI, loader, state, utils, etc.).
   - Focus on **user workflow and configuration**, not on neural network theory, unless explicitly requested.

6. **Preserve Behavior Unless Asked Otherwise**  
   - UI logic (how a node is displayed, how neighbors are chosen) may be refactored, but:
     - Do NOT change basic interaction semantics (click → move to neighbor → re-render) unless explicitly authorized.
     - No silent additions of complex features (e.g. graph layouts, filters) that alter the core UX.

7. **Be Explicit About Modes**  
   - Internally choose the right agent (mode) based on task type.
   - Do not announce the mode to the user, but obey its rules.

---

## 1.x Structural Principles (Modules ↔ Responsibilities)

These constraints apply to *all* modes (UIAgent, NetworkAgent, RefactorAgent, etc.):

1. **One Responsibility per Module**  
   - The main JavaScript files should follow a modular structure, for example:
     - `semnet_main.js` — public entrypoint (called from DataviewJS).
     - `semnet_loader.js` — network JSON loading.
     - `semnet_state.js` — current node, history, active network.
     - `semnet_ui.js` — DOM creation and interaction.
     - `semnet_styles.js` — style / class definitions or CSS injection.
     - `semnet_utils.js` — small helpers only.
   - Codex must avoid creating “god files” that mix all responsibilities.

2. **DataviewJS Entry Must Stay Minimal**  
   - The DataviewJS block should only:
     - load the main module,
     - call its `run()` (or similarly named) function with a config object.
   - Example pattern:
     ```js
     const semnet = await dv.io.load("Scripts/semnet/semnet_main.js");

     await semnet.run({
       container: this.container,
       networkPath: "0-Data/semantic-networks/siechaline-notes-v1.json",
       randomStart: true
     });
     ```

3. **No Hidden Global State Outside `semnet_state.js`**  
   - All runtime state (current node, navigation history, active network id) must go through a dedicated state module.
   - UI modules must access/modify state via explicit functions or a shared state object, not via random globals.

4. **No Plugin-Wide Side Effects Without Justification**  
   - Modules must not:
     - modify unrelated DOM outside the provided container,
     - alter Obsidian’s global styles in a destructive way,
     - add global event listeners that are never cleaned up.
   - Any global CSS injection or event listener must be clearly justified and documented.

5. **Explicit Imports & Relative Paths**  
   - When creating new modules, use explicit relative imports:
     - `import { renderUI } from "./semnet_ui.js";`
   - Codex must keep imports consistent when refactoring or moving files.

---

## 2. UIAgent

**Use this mode when the user asks to:**

- “create the UI for walking the network,”
- “add buttons for neighbors,”
- “update the panel when a node is clicked,”
- “design the layout / styling of the semantic walker.”

**Primary references:**

- `semnet_main.js`
- `semnet_ui.js`
- `semnet_styles.js`
- the agreed JSON format for the network

**Responsibilities:**

- Implement DOM creation for:
  - current node text,
  - neighbor buttons (one per neighbor),
  - a “Finish” or “Stop” button,
  - optional metadata (network title, description, current node id).
- Implement click behavior:
  - clicking a neighbor sets it as the new current node,
  - re-render the panel with its neighbors,
  - optionally maintain a breadcrumb or history view (if explicitly requested).
- Keep the UI responsive and minimal, avoiding heavy frameworks.

**Guardrails:**

- Do NOT implement or modify embedding computations.
- Do NOT silently alter the JSON format.
- Do NOT add complex layouts (force-directed graphs, canvases, etc.) unless explicitly requested.

---

## 3. NetworkAgent

**Use this when the task involves:**

- reading or validating network JSON files,
- adjusting loader logic,
- mapping node IDs to node objects,
- handling multiple network files.

**Primary references:**

- `semnet_loader.js`
- `semnet_utils.js`
- any `index.json` for listing multiple networks (if present)

**Responsibilities:**

1. **Loading a Single Network**
   - Implement `loadNetwork(path)`:
     - use `app.vault.adapter.read(path)` to load the file,
     - `JSON.parse` it,
     - return the network object.

2. **Handling Multiple Networks (Optional)**
   - If asked, implement an index file pattern:
     ```json
     [
       { "id": "siechaline-notes-v1", "path": "0-Data/semantic-networks/siechaline-notes-v1.json" },
       { "id": "thesis-discussion-v2", "path": "0-Data/semantic-networks/thesis-discussion-v2.json" }
     ]
     ```
   - Add helper functions to choose a network by id or present a selection UI.

3. **Utility Functions**
   - Provide helpers:
     - `findNode(network, id)`
     - `getNeighbors(node)` or similar.

**Guardrails:**

- Must not write back to JSON files unless explicitly requested.
- Must not introduce incompatible formats.

---

## 4. StateAgent

**Use this when the user asks to:**

- track navigation history,
- expose current node / path,
- add reset or back buttons,
- introspect the path taken through the network.

**Primary references:**

- `semnet_state.js`

**Responsibilities:**

- Maintain:
  - `currentNode` (id),
  - `history` (list of visited node ids),
  - `network` (reference to loaded network object).
- Provide safe methods:
  - `setCurrentNode(id)`,
  - `getCurrentNode()`,
  - `reset()`,
  - optional: `goBack()` if backtracking is implemented.

**Guardrails:**

- State logic must remain simple and readable.
- No entanglement with network loading (that belongs to NetworkAgent).
- No UI code inside `semnet_state.js`.

---

## 5. RefactorAgent

**Use this when the user asks to:**

- clean up or reorganize modules,
- improve the separation of concerns,
- rename functions, extract helpers, or simplify code.

**Primary references:**

- all `semnet_*.js` files

**Responsibilities:**

- Improve:
  - clarity of module responsibilities,
  - naming consistency (`run`, `renderUI`, `loadNetwork`, etc.),
  - duplication of logic (e.g. repeated `findNode` calls can be centralized).
- Keep:
  - `semnet_main.js` as the public entrypoint,
  - UI logic in `semnet_ui.js`,
  - state logic in `semnet_state.js`,
  - helpers in `semnet_utils.js`.

**Guardrails:**

- Must preserve existing behavior unless explicitly allowed to redesign interaction.
- Must not delete publicly used functions without providing replacements.

---

## 6. PlanningAgent

**Use this when the user asks for:**

- a plan / roadmap for the plugin,
- next features,
- how to support multiple networks or filters,
- how to later integrate additional views (graph layout, projections, etc.).

**Responsibilities:**

- Propose:
  - incremental steps (MVP → v1 → v2),
  - possible additional modules (e.g. `semnet_history_ui.js`, `semnet_filters.js`),
  - strategies for scaling the network (e.g. limiting neighbors, pagination),
  - ways to log or export paths for later analysis.

**Guardrails:**

- Plans must remain consistent with:
  - the read-only-by-default principle for network JSONs,
  - the simple adjacency-list format,
  - the architectural separation between front-end and back-end.

---

## 7. ConceptAgent (Architecture & Explanation)

**Use this when the user asks:**

- “explain how the semantic walker works,”
- “what is the architecture?”,
- “how do modules interact?”,
- “how does DataviewJS call this?”

**Responsibilities:**

- Provide layered explanations:
  - high-level overview of data flow:
    - *DataviewJS → semnet_main → loader → state → UI*,
  - description of the JSON network format,
  - example of a full user interaction from first render to pressing “Finish”.
- Use diagrams (ASCII or Markdown) where helpful.

**Guardrails:**

- Explanations must match the actual implementation.
- No invented features that the repo does not support.

---

## 8. Mode Selection Logic

When a request comes:

1. If it involves **UI elements, buttons, layout, or styling** → `UIAgent`.
2. If it involves **loading or interpreting networks** → `NetworkAgent`.
3. If it involves **navigation history or current node state** → `StateAgent`.
4. If it asks for **cleanup, modularization, or architectural changes** → `RefactorAgent`.
5. If it asks for **plans, roadmaps, or future features** → `PlanningAgent`.
6. If it asks for **explanations of how things work** → `ConceptAgent`.

Mixed requests:

- UI + network loading → let **UIAgent** lead, calling NetworkAgent internally.
- Refactor + UI → let **RefactorAgent** lead, preserving UI semantics.
- Planning + refactor → use PlanningAgent, applying RefactorAgent’s constraints.

Do NOT announce the mode externally; simply obey its rules.

---

## 9. Philosophy of These Agents

These “agents” are internal operation modes that help Codex keep the Semantic Network Walker:

- **Coherent** — same structure and responsibilities across modules,
- **Deterministic** — given a network JSON and config, the UI behaves predictably,
- **Transparent** — the data flow and configuration are easy to understand,
- **Composable** — easy to extend with new views (history panel, filters, projections),
- **Non-destructive** — the UI never corrupts or silently rewrites network data.

They are not separate programs;  
they are behavioral contracts Codex must follow whenever it works inside this repository.

